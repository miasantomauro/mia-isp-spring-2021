#lang forge

/*
  Model of crypto/DS diagrams
  Tim Mia Abby
  Opting to build in normal Forge, not Electrum

   A            B
   |            |
   |----------->|
   |   {foo}_B  |
   |            |
   |<-----------|
   |   {bar}_A  |
       ...
       
time
|
v

*/

sig Datum {}

sig Key extends Datum {}
sig PrivateKey extends Key {}
sig PublicKey extends Key {}
sig SymmetricKey extends Key {}


-- relation to match key pairs -- 

one sig KeyPairs {
 pairs: set PrivateKey -> PublicKey,
 owners: set PrivateKey -> Agent
}

-- t=0, t=1, ...
sig Timeslot {
   tick: lone Timeslot
}

-- As agents are sent messages, they learn pieces of data --
sig Agent extends Datum {
  learned_times: set Datum -> Timeslot
}

sig Orig {
  uniqOrig: set Datum -> Agent
}

one sig Attacker extends Agent {
}

sig Ciphertext extends Datum {
   encryptionKey: one Key,
   -- result in concating plaintexts
   plaintext: set Datum
}


-- {foo}_B
sig Message {
  -- Support delays, non-reception
  sender: one Agent,
  receiver: one Agent,
  attacker: lone Attacker,
  sendTime: one Timeslot,
  recvTime: one Timeslot, -- was lone, changing it to one
  data: set Datum,
  new_message: lone Message
}

pred wellformed {
  -- Design choice: only one message event per timeslot;
  --   assume we have a shared notion of time
  all t: Timeslot | lone sendTime.t + recvTime.t

  -- Note: for the purposes of this demo, messages are received at the same time they are sent
  -- this is a design decision that should be discussed
  all m: Message | m.sendTime = m.recvTime

  -- You cannot send a message with no data
  all m: Message | some m.data

  -- someone cannot send a message to themselves
  all m: Message | m.sender not in m.receiver
  
  -- agents (excluding the attacker) only learn information that they are explicitly sent (this can be changed later)
  all d: Datum | all t: Timeslot | all a: Agent - Attacker | d->t in a.learned_times iff {
    -- they have not already learned the datum -- 
    {d not in (a.learned_times).(Timeslot - t.*tick)} and 

    -- They received the message
    {{some m: Message | {d in m.data and t = m.recvTime and m.receiver = a and no m.attacker}}
    or 
    -- d can be the plaintext of a ciphertext encrypted using a symmetric key which the agent has access to the key
    {some c: Ciphertext | c in (a.learned_times).(Timeslot - t.^tick) and d in c.plaintext and c.encryptionKey in SymmetricKey and c.encryptionKey in (a.learned_times).(Timeslot - t.^tick)}
    or
    -- d is a plaintext of the ciphertext which the agent has access to the key encrypted using a publicKey
    {some c: Ciphertext | c in (a.learned_times).(Timeslot - t.^tick) and d in c.plaintext and c.encryptionKey in PublicKey and KeyPairs.pairs.(c.encryptionKey) in (a.learned_times).(Timeslot - t.^tick)}
    or 
    -- Agent knows all public keys
    {d in PublicKey}
    or
    -- Agent knows the private keys it owns
    {d in PrivateKey and a = d.(KeyPairs.owners)}
    or
    -- Agent can encrypt things
    {d in Ciphertext and d.encryptionKey in (a.learned_times).(Timeslot - t.^tick) and d.plaintext not in Ciphertext and d.plaintext in (a.learned_times).(Timeslot - t.*tick)}
    or
    -- Agents know their own names
    {d = a}
    or
    -- This was a value generated by the agent
    {d.(Orig.uniqOrig) = a}
    }} 

all m: Message | {no new_message.m} implies m.data in ((m.sender).learned_times).(Timeslot - (m.sendTime).^tick) 

  -- adding to the times that the attacker learns things --
  all d: Datum | all t: Timeslot | d->t in Attacker.learned_times iff {
        -- d has not been learend already
        {d not in (Attacker.learned_times).(Timeslot - t.*tick)}
        and 
         -- d is in the message
        {{some m: Message| {d in m.data and t = m.recvTime} and no (new_message).m}
        or 
        -- d can be the plaintext of a ciphertext encrypted using a symmetric key which the attacker has access to the key
        {some c: Ciphertext | c in (Attacker.learned_times).(Timeslot - t.^tick) and d in c.plaintext and c.encryptionKey in SymmetricKey and c.encryptionKey in (Attacker.learned_times).(Timeslot - t.^tick)}
        or 
        -- d is a plaintext of the ciphertext which the attacker has access to the key encrypted using a publicKey
        {some c: Ciphertext | c in (Attacker.learned_times).(Timeslot - t.^tick) and d in c.plaintext and c.encryptionKey in PublicKey and KeyPairs.pairs.(c.encryptionKey) in (Attacker.learned_times).(Timeslot - t.^tick)}
        or 
        -- Attacker knows all public keys
        {d in PublicKey}
        or
        -- Attacker knows privatekeys without owners
        {d in PrivateKey and no d.(KeyPairs.owners)}
        or 
        -- Attacker can encrypt things
        {d in Ciphertext and d.encryptionKey in (Attacker.learned_times).(Timeslot - t.^tick) and d.plaintext not in Ciphertext and d.plaintext in (Attacker.learned_times).(Timeslot - t.*tick)}
        }}

    all original: Message | 
                          {one original.attacker implies {one tampered: Message - original | 
                                                                                            {tampered.data in (Attacker.learned_times).(Timeslot - (original.sendTime).^tick + original.sendTime.tick)} and
                                                                                            {original.new_message = tampered} and
                                                                                            {tampered.receiver = original.receiver} and
                                                                                            {tampered.sender = original.sender} and
                                                                                            {tampered.sendTime = original.sendTime.tick} and
                                                                                            {Attacker not in tampered.attacker}}}

  -- When an attacker tampers with a message, it will be sent after the original message
  all m1: Message | all m2: Message - m1 | (one m1.attacker and m1.new_message = m2) implies m2.sendTime in (m1.sendTime).^tick

  -- Attacker cannot send or receive messages 
  Attacker not in Message.receiver
  Attacker not in Message.sender

  -- don't have a new message if it wasn't tampered with --
  all m: Message | Attacker not in m.attacker implies no m.new_message

  -- plaintext relation is acyclic -- 
  all c: Ciphertext | c not in c.plaintext

  --some m : Message | Attacker in m.attacker

  (KeyPairs.pairs).PublicKey = PrivateKey
  PrivateKey.(KeyPairs.pairs) = PublicKey
  all privKey: PrivateKey | {one pubKey: PublicKey | privKey->pubKey in KeyPairs.pairs}
  all priv1: PrivateKey | all priv2: PrivateKey - priv1 | all pub: PublicKey | priv1->pub in KeyPairs.pairs implies priv2->pub not in KeyPairs.pairs
}


-- NS AS PREDICATES STARTS HERE --
----------------------------------------------------------------------

----- PROTOCOL DEFN -----

/*
  (defprotocol ns basic
  (defrole init
    (vars (a b name) (n1 n2 text))
    (trace (send (enc n1 a (pubk b)))
           (recv (enc n1 n2 (pubk a)))
           (send (enc n2 (pubk b)))))
  (defrole resp 
    (vars (a b name) (n1 n2 text))
    (trace (recv (enc n1 a (pubk b)))
           (send (enc n1 n2 (pubk a)))
           (recv (enc n2 (pubk b))))))
*/

sig Init extends Agent {
  -- variables for an init strand:
  init_a, init_b: one Agent, -- alias for Name
  init_n1, init_n2: one Datum -- alias for Text
}

sig Resp extends Agent {
  -- variables for a resp strand:
  resp_a, resp_b: one Agent, -- alias for Name
  resp_n1, resp_n2: one Datum -- alias for Text
}

pred ns_execution {

  -- We are conflating 'role' and 'strand' somewhat, although
  -- we think it is safe, since 'role' is embodied as a sig, and 
  --   a strand is an atom of that role
  -- ASSUMPTION: strands have exactly one role
  -- ASSUMPTION: not interested in instances where protocol execution is incomplte
  --    (we enforce all strands to observe their full trace)

  all init: Init | {  
    some t0: Timeslot | 
    some t1: t0.^tick | 
    some t2: t1.^tick | 
    some m0: Message | 
    some m1: Message - m0 | 
    some m2: Message - m1 - m0 | {  
      m0.sendTime = t0
      m1.sendTime = t1
      m2.sendTime = t2

  --  (trace (send (enc n1 a (pubk b)))
      -- contains local values for "a" and "n1"
      m0.data.plaintext = init.init_a + init.init_n1

      one m0.data
      -- encrypted with public key of whoever is locally "b"
      -- recall "owners" takes us to private key, and then lookup in pairs
      m0.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(init.init_b)]
      m0.sender = init
  --         (recv (enc n1 n2 (pubk a)))
      m1.data.plaintext = init.init_n1 + init.init_n2     
      one m1.data
      m1.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(init.init_a)]
      m1.receiver = init
  --         (send (enc n2 (pubk b)))))
      m2.data.plaintext = init.init_n2   
      one m2.data   
      m2.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(init.init_b)]
      m2.sender = init    
    }      
  }

  all resp: Resp | {  
    some t0: Timeslot | 
    some t1: t0.^tick | 
    some t2: t1.^tick | 
    some m0: Message | 
    some m1: Message - m0 | 
    some m2: Message - m1 - m0 | {  
      m0.sendTime = t0
      m1.sendTime = t1
      m2.sendTime = t2

    --(trace (recv (enc n1 a (pubk b)))                
      -- contains local values for "a" and "n1"
      m0.data.plaintext = resp.resp_a + resp.resp_n1
      one m0.data
      -- encrypted with public key of whoever is locally "b"
      -- recall "owners" takes us to private key, and then lookup in pairs
      m0.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(resp.resp_b)]
      m0.receiver = resp
  --       (send (enc n1 n2 (pubk a)))
      m1.data.plaintext = resp.resp_n1 + resp.resp_n2     
      one m1.data
      m1.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(resp.resp_a)]
      m1.sender = resp
  --        (recv (enc n2 (pubk b))))))
      m2.data.plaintext = resp.resp_n2 
      one m2.data     
      m2.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(resp.resp_b)]
      m2.receiver = resp
    }      
  }
}

----- SKELETON DEFNS -----

/*
(defskeleton ns
 (vars (b name) (n1 text))
 (defstrand init 3 (b b) (n1 n1))
  (non-orig (privk b)) (uniq-orig n1)) 
(defskeleton ns
  (vars (a name) (n2 text))
 (defstrand resp 3 (a a) (n2 n2))
  (non-orig (privk a)) (uniq-orig n2))
*/
-- TODO: look at defskeleton and defstrand docs
--  what is the (b b)? ANSWER: this is defining the variable b in the role to the value of b
--  why say "3" there if init/resp traces have 3 messages each?  This is the max height.  You could not put more than 3 here, but you can put less than 3

-- Assume: defskeleton ns: the strands herein are NS roles
-- Assume: defstrand init ... is talking about a specific init strand

/* -- does this make sense? 
abstract sig Skeleton {}
sig Skeleton0 extends Skeleton {
  s0_b: Agent,
  s0_n1: Datum
}
sig Skeleton1 extends Skeleton {
  s1_a: Agent,
  s1_n2: Datum
}
*/
// ??? 



// TODO

pred exploit_search {
  some na: Datum - Agent | 
  some c: Ciphertext | 
  some m: Message | {
    m.data = c and
    na in c.plaintext and
    na in Attacker.learned_times.(Timeslot - (m.sendTime).^tick)
  }
}


run {
  wellformed 
  ns_execution 
  --exploit_search
} for 15 Datum, 6 Key, 3 PublicKey, 5 Ciphertext, exactly 3 Agent, 
      exactly 1 Init, exactly 1 Resp 
  for {tick is linear}