#lang forge

/*
  Model of crypto/DS diagrams
  Tim Mia Abby
  Opting to build in normal Forge, not Electrum

   A            B
   |            |
   |----------->|
   |   {foo}_B  |
   |            |
   |<-----------|
   |   {bar}_A  |
       ...
       
time
|
v

*/

sig Datum {}

sig Key extends Datum {}
sig PrivateKey extends Key {}
sig PublicKey extends Key {}
sig SymmetricKey extends Key {}


-- relation to match key pairs -- 

one sig KeyPairs {
 pairs: set PrivateKey -> PublicKey,
 owners: set PrivateKey -> Agent
}

-- t=0, t=1, ...
sig Timeslot {
   tick: lone Timeslot
}

-- As agents are sent messages, they learn pieces of data --
sig Agent extends Datum {
  learned_times: set Datum -> Timeslot
}

sig Orig {
  uniqOrig: set Datum -> Agent
}

one sig Attacker extends Agent {
}

sig Ciphertext extends Datum {
   encryptionKey: one Key,
   -- result in concating plaintexts
   plaintext: set Datum
}


-- {foo}_B
sig Message {
  -- Support delays, non-reception
  sender: one Agent,
  receiver: one Agent,
  attacker: lone Attacker,
  sendTime: one Timeslot,
  recvTime: one Timeslot, -- was lone, changing it to one
  data: set Datum,
  new_message: lone Message
}

pred wellformed {
  -- Design choice: only one message event per timeslot;
  --   assume we have a shared notion of time
  all t: Timeslot | lone sendTime.t + recvTime.t

  -- Note: for the purposes of this demo, messages are received at the same time they are sent
  -- this is a design decision that should be discussed
  all m: Message | m.sendTime = m.recvTime

  -- You cannot send a message with no data
  all m: Message | some m.data

  -- someone cannot send a message to themselves
  all m: Message | m.sender not in m.receiver
  
  -- agents (excluding the attacker) only learn information that they are explicitly sent (this can be changed later)
  all d: Datum | all t: Timeslot | all a: Agent - Attacker | d->t in a.learned_times iff {
    {d not in (a.learned_times).(Timeslot - t.*tick)} and 
    {{some m: Message | {d in m.data and t = m.recvTime and m.receiver = a and no m.attacker}}
    or 
    -- d can be the plaintext of a ciphertext encrypted using a symmetric key which the agent has access to the key
    {some c: Ciphertext | c in (a.learned_times).(Timeslot - t.^tick) and d in c.plaintext and c.encryptionKey in SymmetricKey and c.encryptionKey in (a.learned_times).(Timeslot - t.^tick)}
    or
    -- d is a plaintext of the ciphertext which the agent has access to the key encrypted using a publicKey
    {some c: Ciphertext | c in (a.learned_times).(Timeslot - t.^tick) and d in c.plaintext and c.encryptionKey in PublicKey and KeyPairs.pairs.(c.encryptionKey) in (a.learned_times).(Timeslot - t.^tick)}
    or 
    -- Agent knows all public keys
    {d in PublicKey}
    or
    -- Agent knows the private keys it owns
    {d in PrivateKey and a = d.(KeyPairs.owners)}
    or
    -- Agent can encrypt things
    {d in Ciphertext and d.encryptionKey in (a.learned_times).(Timeslot - t.^tick) and d.plaintext not in Ciphertext and d.plaintext in (a.learned_times).(Timeslot - t.*tick)}
    or
    -- Agents know their own names
    {d = a}
    or
    -- This was a value generated by the agent
    {d.(Orig.uniqOrig) = a}
    }} 

all m: Message | {no m.new_message and no new_message.m} implies m.data in ((m.sender).learned_times).(Timeslot - (m.sendTime).^tick)
--all m: Message | one m.attacker implies m.data in ((m.sender).learned_times).(Timeslot - (m.sendTime).^tick)
 

  -- adding to the times that the attacker learns things --
  all d: Datum | all t: Timeslot | d->t in Attacker.learned_times iff {
        -- d has not been learend already
        {d not in (Attacker.learned_times).(Timeslot - t.*tick)}
        and 
         -- d is in the message
        {{some m: Message| {d in m.data and t = m.recvTime} and no (new_message).m}
        or 
        -- d can be the plaintext of a ciphertext encrypted using a symmetric key which the attacker has access to the key
        {some c: Ciphertext | c in (Attacker.learned_times).(Timeslot - t.^tick) and d in c.plaintext and c.encryptionKey in SymmetricKey and c.encryptionKey in (Attacker.learned_times).(Timeslot - t.^tick)}
        or 
        -- d is a plaintext of the ciphertext which the attacker has access to the key encrypted using a publicKey
        {some c: Ciphertext | c in (Attacker.learned_times).(Timeslot - t.^tick) and d in c.plaintext and c.encryptionKey in PublicKey and KeyPairs.pairs.(c.encryptionKey) in (Attacker.learned_times).(Timeslot - t.^tick)}
        or 
        -- Attacker knows all public keys
        {d in PublicKey}
        or
        -- Attacker knows privatekeys without owners
        {d in PrivateKey and no d.(KeyPairs.owners)}
        or 
        -- Attacker can encrypt things
        {d in Ciphertext and d.encryptionKey in (Attacker.learned_times).(Timeslot - t.^tick) and d.plaintext not in Ciphertext and d.plaintext in (Attacker.learned_times).(Timeslot - t.*tick)}
        }}

    all original: Message | 
                          {one original.attacker implies {one tampered: Message - original | 
                                                                                            {tampered.data in (Attacker.learned_times).(Timeslot - (original.sendTime).^tick + original.sendTime.tick)} and
                                                                                            {original.new_message = tampered} and
                                                                                            {tampered.receiver = original.receiver} and
                                                                                            {tampered.sender = original.sender} and
                                                                                            {tampered.sendTime = original.sendTime.tick} and
                                                                                            {Attacker not in tampered.attacker}}}

  -- When an attacker tampers with a message, it will be sent after the original message
  all m1: Message | all m2: Message - m1 | (one m1.attacker and m1.new_message = m2) implies m2.sendTime in (m1.sendTime).^tick

  -- Attacker cannot send or receive messages 
  Attacker not in Message.receiver
  Attacker not in Message.sender

  -- don't have a new message if it wasn't tampered with --
  all m: Message | Attacker not in m.attacker implies no m.new_message

  -- plaintext relation is acyclic -- 
  all c: Ciphertext | c not in c.plaintext

  some m : Message | Attacker in m.attacker

  (KeyPairs.pairs).PublicKey = PrivateKey
  PrivateKey.(KeyPairs.pairs) = PublicKey
  all privKey: PrivateKey | {one pubKey: PublicKey | privKey->pubKey in KeyPairs.pairs}

}

/*inst boundedDemo {
Agent = Alice + Bob + Eve
Attacker = Eve

Timeslot = Timeslot0 + Timeslot1 + Timeslot2 + Timeslot3 + Timeslot4

Datum = Agent + na + nb + nc + Ciphertext0 + Ciphertext1 + Ciphertext2 + Ciphertext3 + Ciphertext4 + PubKa + PubKb + PrivKa + PrivKb + PrivKc + PubKc  

Ciphertext = Ciphertext0 + Ciphertext1 + Ciphertext2 + Ciphertext3 + Ciphertext4

plaintext in Ciphertext0->na + Ciphertext0->Alice + Ciphertext1->na + Ciphertext1->Alice + Ciphertext2->na + Ciphertext2->nb + Ciphertext3->nb + Ciphertext4->nb + Ciphertext4->na + Ciphertext4->PubKc + Ciphertext4->PubKb
encryptionKey in Ciphertext0->PubKc + Ciphertext1->PubKb + Ciphertext2->PubKa + Ciphertext3->PubKc + Ciphertext4->PubKb + Ciphertext4->PubKc + Ciphertext4->PubKb

plaintext ni Ciphertext0->na + Ciphertext0->Alice + Ciphertext1->na + Ciphertext1->Alice + Ciphertext2->na + Ciphertext2->nb + Ciphertext3->nb + Ciphertext4->nb
encryptionKey ni Ciphertext0->PubKc + Ciphertext1->PubKb + Ciphertext2->PubKa + Ciphertext3->PubKc + Ciphertext4->PubKb

Key = PubKa + PubKb + PrivKa + PrivKb + PubKc + PrivKc
PrivateKey = PrivKb + PrivKa + PrivKc
PublicKey = PubKa + PubKb + PubKc

Message = Message0 + Message1 + Message2 + Message3 + Message4
sender = Message0->Alice + Message1->Alice + Message2->Bob + Message3->Alice + Message4->Alice
receiver = Message0->Bob + Message1->Bob + Message2->Alice + Message3->Bob + Message4->Bob

data = Message0->Ciphertext0 + Message1->Ciphertext1 + Message2->Ciphertext2 + Message3->Ciphertext3 + Message4->Ciphertext4
sendTime = Message0->Timeslot0 + Message1->Timeslot1 + Message2->Timeslot2 + Message3->Timeslot3 + Message4->Timeslot4 

tick = Timeslot0->Timeslot1 + Timeslot1->Timeslot2 + Timeslot2->Timeslot3 + Timeslot3->Timeslot4

KeyPairs = KP1
pairs = KP1->PrivKa->PubKa + KP1->PrivKb->PubKb + KP1->PrivKc->PubKc
owners = KP1->PrivKa->Alice + KP1->PrivKb->Bob 

attacker = Message3->Eve + Message0->Eve
new_message = Message3->Message4 + Message0->Message1

Orig = O1
uniqOrig = O1->na->Alice + O1->nb->Bob
}*/


inst paperExploit {
Agent = Alice + Bob + Eve
Attacker = Eve

Timeslot = Timeslot0 + Timeslot1 + Timeslot2 + Timeslot3 + Timeslot4

Datum = Agent + na + nb + Ciphertext0 + Ciphertext1 + Ciphertext2 + Ciphertext3 + Ciphertext4 + PubKa + PubKb + PrivKa + PrivKb + PrivKc + PubKc  

Ciphertext = Ciphertext0 + Ciphertext1 + Ciphertext2 + Ciphertext3 + Ciphertext4

plaintext = Ciphertext0->na + Ciphertext0->Alice + Ciphertext1->na + Ciphertext1->Alice + Ciphertext2->na + Ciphertext2->nb + Ciphertext3->nb + Ciphertext4->nb
encryptionKey = Ciphertext0->PubKc + Ciphertext1->PubKb + Ciphertext2->PubKa + Ciphertext3->PubKc + Ciphertext4->PubKb
Key = PubKa + PubKb + PrivKa + PrivKb + PubKc + PrivKc
PrivateKey = PrivKb + PrivKa + PrivKc
PublicKey = PubKa + PubKb + PubKc

Message = Message0 + Message1 + Message2 + Message3 + Message4
sender = Message0->Alice + Message1->Alice + Message2->Bob + Message3->Alice + Message4->Alice
receiver = Message0->Bob + Message1->Bob + Message2->Alice + Message3->Bob + Message4->Bob

data = Message0->Ciphertext0 + Message1->Ciphertext1 + Message2->Ciphertext2 + Message3->Ciphertext3 + Message4->Ciphertext4
sendTime = Message0->Timeslot0 + Message1->Timeslot1 + Message2->Timeslot2 + Message3->Timeslot3 + Message4->Timeslot4 

tick = Timeslot0->Timeslot1 + Timeslot1->Timeslot2 + Timeslot2->Timeslot3 + Timeslot3->Timeslot4

KeyPairs = KP1
pairs = KP1->PrivKa->PubKa + KP1->PrivKb->PubKb + KP1->PrivKc->PubKc
owners = KP1->PrivKa->Alice + KP1->PrivKb->Bob 

attacker = Message3->Eve + Message0->Eve
new_message = Message3->Message4 + Message0->Message1

Orig = O1
uniqOrig = O1->na->Alice + O1->nb->Bob
}


/*inst instNSExploit { 
  -- Alice is init in this case
  Agent = Alice + Bob + Eve
  Attacker = Eve

  Timeslot in Timeslot0 + Timeslot1 + Timeslot2 + Timeslot3 + Timeslot4
  Timeslot ni Timeslot0 + Timeslot1 + Timeslot2 

  Datum in Agent + n1 + n2 + n3 + Ciphertext0 + Ciphertext1 + Ciphertext2 + Ciphertext3 + Ciphertext4 + PubKa + PubKb + PrivKa + PrivKb + PrivKc + PubKc  
  Datum ni Agent + n1 + n2 + Ciphertext0 + Ciphertext1 + Ciphertext2 + PubKa + PubKb + PrivKa + PrivKb

  Ciphertext in Ciphertext0 + Ciphertext1 + Ciphertext2 + Ciphertext3 + Ciphertext4
  Ciphertext ni Ciphertext0 + Ciphertext1 + Ciphertext2 

  plaintext in Ciphertext0->n1 + Ciphertext0->Alice + Ciphertext1->n1 + Ciphertext1->n2 + Ciphertext2->n2 + Ciphertext3->Alice + Ciphertext3->n1 + Ciphertext4->n2
  plaintext ni Ciphertext0->n1 + Ciphertext0->Alice + Ciphertext1->n1 + Ciphertext1->n2 + Ciphertext2->n2
  
  encryptionKey in Ciphertext0->PubKb + Ciphertext1->PubKa + Ciphertext2->PubKb + Ciphertext3->PubKb + Ciphertext3->PubKa + Ciphertext3->PubKc + Ciphertext4->PubKc
  encryptionKey ni Ciphertext0->PubKb + Ciphertext1->PubKa + Ciphertext2->PubKb

  Key in PubKa + PubKb + PrivKa + PrivKb + PubKc + PrivKc
  Key ni PubKa + PubKb + PrivKa + PrivKb

  PrivateKey in PrivKa + PrivKb + PrivKc
  PrivateKey ni PrivKa + PrivKb

  PublicKey in PubKa + PubKb + PubKc
  PublicKey ni PubKa + PubKb

  Message in Message0 + Message1 + Message2 + Message3 + Message4
  Message ni Message0 + Message1 + Message2

  sender in Message0->Alice + Message1->Bob + Message2->Alice + Message3->Alice + Message3->Bob + Message3->Eve + Message4->Alice
  sender ni Message0->Alice + Message1->Bob + Message2->Alice

  receiver in Message0->Bob + Message1->Alice + Message2->Bob + Message3->Alice + Message3->Bob + Message4->Bob
  receiver ni Message0->Bob + Message1->Alice + Message2->Bob

  data in Message0->Ciphertext0 + Message1->Ciphertext1 + Message2->Ciphertext2 + Message3->Ciphertext3 + Message4->Ciphertext4 + Message3->Ciphertext2 + Message3->Ciphertext1
  data ni Message0->Ciphertext0 + Message1->Ciphertext1 + Message2->Ciphertext2

  sendTime = Message0->Timeslot0 + Message1->Timeslot2 + Message2->Timeslot3 + Message3->Timeslot1 + Message4->Timeslot4 
  --sendTime ni Message0->Timeslot0 + Message1->Timeslot1 + Message2->Timeslot2

  tick = Timeslot0->Timeslot1 + Timeslot1->Timeslot2 + Timeslot2->Timeslot3 + Timeslot3->Timeslot4

  KeyPairs = KP1
  pairs = KP1->PrivKa->PubKa + KP1->PrivKb->PubKb + KP1->PrivKc->PubKc
  owners in KP1->PrivKa->Alice + KP1->PrivKb->Bob + KP1->PrivKc->Alice + KP1->PrivKc->Bob
  owners ni KP1->PrivKa->Alice + KP1->PrivKb->Bob

  new_message = Message0->Message3 + Message2->Message4

  Orig = O1
  uniqOrig = O1->n1->Alice + O1->n2->Bob

}*/

option verbose 10
run {
  wellformed
} for paperExploit

/*run {
  wellformed
} for exactly 3 Agent, 8 Timeslot, exactly 2 Message, exactly 1 Ciphertext, exactly 1 SymmetricKey, exactly 1 PublicKey, exactly 1 PrivateKey, exactly 10 Datum for {tick is linear}*/