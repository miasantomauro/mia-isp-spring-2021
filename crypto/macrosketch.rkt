#lang forge/core

; Module to accept CPSA protocol and skeleton definitions and enhance a
; base crypto specification with protocol/skeleton-specific sigs and constraints.
;   Tim and Abby (Spring 2021)

;https://hackage.haskell.org/package/cpsa-3.3.2/src/doc/cpsamanual.pdf
; At the moment, we have prototype support for the "basic" algebra, using only
;   asymmetric keys. 


; Comments from Ben for integration with prototype:
; each role is getting parsed twice (with defroleClass); make roleforge be a function and have defprotocol do more work --- unpacking things from each of the roles
; could kill the flatten with the in-value trick: (for*/list ((decls ....) (type (in-value (last ....))) (varid ....)) ....)
; the take could be drop-right
; for order-independence:
;    use the seq-no-order package https://docs.racket-lang.org/seq-no-order/index.html

(require (for-syntax racket/syntax))
(require syntax/parse syntax/parse/define)
(require (for-syntax (only-in racket take last flatten drop-right)))


; For debugging speed, don't import the full spec yet
(sig Agent)
; TODO: swap above with the below, once finalized
;(require "current_model.rkt") ; the base crypto modl

; First, define some syntax classes to ease parsing and improve errors.
; Syntax classes can expose custom attributes, which make them easier to process.
; Since these classes are used by macros, we need to define them for-syntax
(begin-for-syntax

  ;(defrole init
  ;    (vars (a b name) (n1 n2 text))
  ;    (trace (send (enc n1 a (pubk b)))
  ;           (recv (enc n1 n2 (pubk a)))
  ;           (send (enc n2 (pubk b)))))
  (struct ast-role (rname vars trace))
  (define-syntax-class defroleClass
    (pattern ((~literal defrole)
              rname:id
              vars:varsClass
              trace:traceClass)             
             #:attr vardecls #'(vars.decls ...)
             #:attr tostruct #`(ast-role rname vars.tostruct trace.tostruct)
             ))
  
;  (vars (a b name) (n1 n2 text))
  (define-syntax-class varsGrouping
    (pattern (var-or-type:id ...)))
  (struct ast-vars (assoc-decls))
  (define-syntax-class varsClass
    (pattern ((~literal vars)
              decls:varsGrouping ...)
             #:attr tostruct #`(ast-vars #,(apply append
                                                  (for/list ([d (syntax->list #'(decls ...))])
                                                    (let ([type (last (syntax->list d))])
                                                      (for/list ([v (drop-right (syntax->list d) 1)])
                                                        #''(#,v #,type))))))))  
  
;    (trace (send (enc n1 a (pubk b)))
;           (recv (enc n1 n2 (pubk a)))
;           (send (enc n2 (pubk b)))))    
  (struct ast-trace (events))
  (define-syntax-class traceClass
    (pattern ((~literal trace)
              events:eventClass ...)
             #:attr tostruct #`(ast-trace events.tostruct ...)))

  (struct ast-event (type contents))
  (define-syntax-class eventClass
    (pattern ((~literal send) enc:encClass)
             #:attr tostruct #`(ast-event 'send enc.tostruct))
    (pattern ((~literal recv) enc:encClass)
             #:attr tostruct #`(ast-event 'recv enc.tostruct)))
  
  (struct ast-enc (key vals))
  (define-syntax-class encClass
    (pattern ((~literal enc)
              vals:id ...
              key:datumClass)
             #:attr tostruct #`(ast-enc key.tostruct (vals ...))))

  ;  (non-orig (privk a) (privk b))
  (define-syntax-class nonOrigClass
    (pattern ((~literal non-orig)
              data:datumClass ...)))
  ;  (uniq-orig n2)
  (define-syntax-class uniqOrigClass
    (pattern ((~literal uniq-orig)
              data:datumClass ...)))
  
  ; n1, a, (pubk a), (privk a)
  (struct ast-datum (wrap id))
  (define-syntax-class datumClass
    (pattern ((~literal privk) x:id)
             #:attr tostruct #`(ast-datum 'privk 'id))
    (pattern ((~literal pubk) x:id)
             #:attr tostruct #`(ast-datum 'pubk 'id))
    (pattern x:id
             #:attr tostruct #`(ast-datum #f 'id)))

  ; (a1 a2)
  ; Name is from CPSA docs
  (define-syntax-class mapletClass
    (pattern (x1:id x2:id)
             #:attr tostruct #''(x1 x2)))

  ; (comment "this is a comment")
  (define-syntax-class commentClass
    (pattern ((~literal comment) comment:string)))
    
  ;  (defstrand resp 3 (a a) (b b) (n2 n2))
  (struct ast-strand (role height maplets))
  (define-syntax-class strandClass
    (pattern ((~literal defstrand)
              strandrole:id
              height:number
              maplets:mapletClass ...)
             #:attr tostruct #`(ast-strand 'strandrole height '(maplets.tostruct ...))))

) ; end begin-for-syntax


; Helper syntax, generated by "defprotocol" to add context
; Produces forge declarations (sigs, relations, predicates...) for a role
(define-syntax (roleforge stx)
  (syntax-parse stx
    [(roleforge pname:id role:defroleClass)
     (with-syntax ([rolesig (format-id #'pname "~a_~a" #'pname #'role.rname)])
       #`(begin
           ; subsig for agents having this role
           (sig rolesig #:extends Agent) ; declare sig
           ; variable fields of that subsig as declared
           #,@(build-variable-fields #'role.vardecls #'pname #'role.rname #'rolesig)
           ; execution predicate for agents having this role
           (pred #,(format-id #'pname "exec_~a_~a" #'pname #'role.rname) #,(build-role-predicate-body #'rolesig #'role.trace))
           ; ^ TODO predicate body
           ))]))

(define-for-syntax (build-variable-fields vardecls name1 name2 parent #:prefix [prefix ""])
  (flatten
   (for/list ([decls (syntax->list vardecls)]) ; for each variable grouping                      
     (let ([type (last (syntax->list decls))])      ; last element is the type
       (for/list ([varid (take (syntax->list decls) (- (length (syntax->list decls)) 1))]) ; for each var decl                          
         #`(relation
            #,(format-id name1 "~a~a_~a_~a" prefix name1 name2 varid)
            (#,parent #,type)))))))

; Cannot get a-trace.events etc. outside syntax-parse. Instead, take a struct description
(define-for-syntax (build-role-predicate-body rolesig a-trace)
  (printf "traces: ~a~n" a-trace)
  (let ([len #'traces.num-events])
    (with-syntax ([rv (format-id rolesig "x_~a_~a" rolesig (gensym))])
      #`(all ([rv #,rolesig])
             (some ([temp Int]);(#,(for/list ([tr (syntax->list #'traces.events)]) [REPLACEME Timeslot]))
                   true)))))


; Main macro for defprotocol declarations
(define-syntax (defprotocol stx)
  (syntax-parse stx [(defprotocol pname:id ptype:id roles:defroleClass ...)
                     (quasisyntax/loc stx
                       (begin (roleforge pname roles) ...))]))

;(defskeleton ns
;  (vars (a b name) (n2 text))
;  (defstrand resp 3 (a a) (b b) (n2 n2))
;  (non-orig (privk a) (privk b))
;  (uniq-orig n2)
;  (comment "Responder point-of-view"))

; Main macro for defskeleton declarations
; Note optional comment parameter
; since skeletons aren't named by the input, generate our own index
(define-for-syntax (unbox-and-increment b)
  (let ([result (unbox b)])
    (set-box! b (+ result 1))
    result))
(define-for-syntax skeleton-index (box 0))

(define-syntax (defskeleton stx)
  (syntax-parse stx [(defskeleton pname:id vars:varsClass strand:strandClass
                       non-orig:nonOrigClass uniq-orig:uniqOrigClass (~optional comment:commentClass))
                     (let ([idx (unbox-and-increment skeleton-index)])
                       (with-syntax ([parentsig (format-id #'pname "skeleton_~a_~a" #'pname idx)])
                       (quasisyntax/loc stx
                         (begin
                           ; subsig for skeleton
                           (sig parentsig #:one) ; declare sig
                           ; variable fields (similar to protocol case: TODO -- factor)
                           #,@(build-variable-fields #'(vars.decls ...) #'pname idx #'parentsig #:prefix "skeleton_")
                           ; TODO: predicate body
                           (pred #,(format-id #'pname "constrain_skeleton_~a_~a" #'pname idx) true)
                           ))))]))
;(pname vars strand non-orig uniq-orig comment)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tests (local for now)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Needham-Schroeder example from CSPA
(defprotocol ns basic
  (defrole init
    (vars (a b name) (n1 n2 text))
    (trace (send (enc n1 a (pubk b)))
           (recv (enc n1 n2 (pubk a)))
           (send (enc n2 (pubk b)))))
  (defrole resp 
    (vars (a b name) (n1 n2 text))
    (trace (recv (enc n1 a (pubk b)))
           (send (enc n1 n2 (pubk a)))
           (recv (enc n2 (pubk b))))))

(defskeleton ns
  (vars (a b name) (n1 text))
  (defstrand init 3 (a a) (b b) (n1 n1))
  (non-orig (privk b) (privk a))
  (uniq-orig n1)
  (comment "Initiator point-of-view"))

(defskeleton ns
  (vars (a b name) (n2 text))
  (defstrand resp 3 (a a) (b b) (n2 n2))
  (non-orig (privk a) (privk b))
  (uniq-orig n2)
  (comment "Responder point-of-view"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Confirm
(hash-keys (forge:State-sigs forge:curr-state))
(hash-keys (forge:State-relations forge:curr-state))
(hash-keys (forge:State-pred-map forge:curr-state))
(relation-typelist ns_init_a)
(relation-typelist skeleton_ns_0_n1)
; Notes:
; Basic algebra has sorts (Table 10.3):
;   text|data|name|tag|skey|akey|mesg
;     skey and akey are symmetric and asymmetric keys
;   data vs text: page 21 says they are interchangeable, but disjoint
;     "both are available for cases where an analyst may wish to describe
;      a protocol in which two types of simple values exist that cannot be
;      confused for each other."
