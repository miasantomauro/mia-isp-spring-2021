#lang forge

/*
  Base model of strand space (style) crypto
  Tim Mia Abby
  Opting to build in normal Forge, not Electrum
*/

abstract sig mesg {} -- CPSA name for any term

sig Key extends mesg {}
sig PrivateKey extends Key {}
sig PublicKey extends Key {}
sig skey extends Key {}


-- relation to match key pairs -- 

one sig KeyPairs {
  pairs: set PrivateKey -> PublicKey,
  owners: set PrivateKey -> name,
  ltks: set name -> name -> skey
}

fun getLTK[name_a: name, name_b: name]: one skey {
  (KeyPairs.ltks)[name_a][name_b]
}

-- t=0, t=1, ...
sig Timeslot {
  next: lone Timeslot
}

-- As names are sent messagest, they learn pieces of data --
sig name extends mesg {
  learned_times: set mesg -> Timeslot,
  generated_times: set text -> Timeslot
}

sig strand {
  -- the name associated with this strand
  agent: one name
}
one sig AttackerStrand extends strand {}

one sig Attacker extends name {}

sig Ciphertext extends mesg {
   encryptionKey: one Key,
   -- result in concating plaintexts
   plaintext: set mesg
}

-- Non-name base value (e.g., nonces)
sig text extends mesg {}

-- {foo}_B
-- Note: this is NOT the same as "mesg"
sig Message {
  -- Support delays, non-reception
  sender: one strand,
  receiver: one strand,
  sendTime: one Timeslot,
  data: set mesg
}

pred wellformed {
  -- Design choice: only one message event per timeslot;
  --   assume we have a shared notion of time
  
 all t: Timeslot | lone sendTime.t 

  -- You cannot send a message with no data
  all m: Message | some m.data

  -- someone cannot send a message to themselves
  all m: Message | m.sender not in m.receiver
  
  -- names only learn information that associated strands are explicitly sent 
  all d: mesg | all t: Timeslot | all a: name | d->t in a.learned_times iff {
    -- they have not already learned the mesg -- 
    {d not in (a.learned_times).(Timeslot - t.*next)} and 

    -- They received the message
    {{some m: Message | {d in m.data and t = m.sendTime and m.receiver.agent = a}}
    or 
    -- d can be the plaintext of a currently-known ciphertext
    --   encrypted using a currently-known key (regardless of the timeslot's message)
    {some c: Ciphertext | 
        c in (a.learned_times).(Timeslot - t.^next) and 
        d in c.plaintext and 
        --c.encryptionKey in skey and
        -- Either pub/priv keypair OR a LTK (symmetric)
        (KeyPairs.pairs.(c.encryptionKey) + c.encryptionKey)
        in (a.learned_times).(Timeslot - t.^next)}
    or
--    {some c: Ciphertext | 					
--        c in (a.learned_times).(Timeslot - t.^next) and 
--        d in c.plaintext and 
--       -- c.encryptionKey in PublicKey and 
--       KeyPairs.pairs.(c.encryptionKey) in (a.learned_times).(Timeslot - t.^next)}
--    or 
    -- name knows all public keys
    {d in PublicKey}
    or
    -- name knows the private keys it owns
    {d in PrivateKey and a = d.(KeyPairs.owners)}
    -- name knows long-term keys they are party to
    or
    {some a2 : name - a | d in getLTK[a, a2] + getLTK[a2, a] }
    or
    -- name can *encrypt* things they know with a key they know
    {d in Ciphertext and 
	d.encryptionKey in (a.learned_times).(Timeslot - t.^next) and
        -- removed to allow nested encryption
	--{all a: d.plaintext | a not in Ciphertext} and 
	d.plaintext in (a.learned_times).(Timeslot - t.^next)}
    or 
    -- names know their own names
    {d = a}
    or
    -- This was a value generated by the name in this timeslot
    {d in (a.generated_times).t}    
    }} 
  
  -- If you generate something, you do it once only
  all a: name | all d: text | lone t: Timeslot | d in (a.generated_times).t

  -- Messages comprise only values known by the sender
  all m: Message | m.data in (((m.sender).agent).learned_times).(Timeslot - (m.sendTime).^next) 

  all m: Message | m.sender = AttackerStrand or m.receiver = AttackerStrand 

  -- plaintext relation is acyclic  
  --  NOTE WELL: if ever add another type of mesg that contains data, + inside ^.
  all d: mesg | d not in d.^(plaintext)

  all c: Ciphertext | some c.plaintext

  (KeyPairs.pairs).PublicKey = PrivateKey -- total
  PrivateKey.(KeyPairs.pairs) = PublicKey -- total
  all privKey: PrivateKey | {one pubKey: PublicKey | privKey->pubKey in KeyPairs.pairs} -- uniqueness
  all priv1: PrivateKey | all priv2: PrivateKey - priv1 | all pub: PublicKey | priv1->pub in KeyPairs.pairs implies priv2->pub not in KeyPairs.pairs

  -- at most one long-term key per (ordered) pair of names
  all a:name, b:name | lone getLTK[a,b]

  -- Attacker's strand
  AttackerStrand.agent = Attacker
}

fun subterm[supers: set mesg]: set mesg {
  -- VITAL: if you add a new subterm relation, needs to be added here, too!
  supers +
  supers.^(plaintext) -- union on new subterm relations inside parens
}

-- Differs slightly in that a is a strand, not a node
pred originates[a: name, d: mesg] {

  -- unsigned term t originates on n in N iff
  --   term(n) is positive and
  --   t subterm of term(n) and
  --   whenever n' precedes n on the same strand, t is not subterm of n'

  some m: sender.agent.a | { -- messages sent by a (positive term)     
      d in subterm[m.data] -- d is a sub-term of m     
      all m2: (sender.agent.a + receiver.agent.a) - m | { -- everything else on the strand
          -- ASSUME: messages are sent/received in same timeslot
          {m2.sendTime in m.sendTime.^(~(next))}
          implies          
          {d not in subterm[m2.data]}
      }
  }
}

pred generates[a: name, d: mesg] {
  some (a.generated_times)[d]
}


-- NS AS PREDICATES STARTS HERE --
----------------------------------------------------------------------

----- PROTOCOL DEFN -----

/*
  (defprotocol ns basic
  (defrole init
    (vars (a b name) (n1 n2 text))
    (trace (send (enc n1 a (pubk b)))
           (recv (enc n1 n2 (pubk a)))
           (send (enc n2 (pubk b)))))
  (defrole resp 
    (vars (a b name) (n1 n2 text))
    (trace (recv (enc n1 a (pubk b)))
           (send (enc n1 n2 (pubk a)))
           (recv (enc n2 (pubk b))))))
*/

sig Init extends strand {
  -- variables for an init strand:
  init_a, init_b: one name, -- alias for Name
  init_n1, init_n2: one text 
}

sig Resp extends strand {
  -- variables for a resp strand:
  resp_a, resp_b: one name, -- alias for Name
  resp_n1, resp_n2: one text
}

pred ns_execution {
  
  -- We are conflating 'role' and 'strand' somewhat, although
  -- we think it is safe, since 'role' is embodied as a sig, and 
  --   a strand is an atom of that role
  -- ASSUMPTION: strands have exactly one role
  -- ASSUMPTION: not interested in instances where protocol execution is incomplte
  --    (we enforce all strands to observe their full trace)

  all init: Init | {  
    some m0: Message | 
    some m1: Message - m0 | 
    some m2: Message - m1 - m0 | {  

      m1.sendTime in m0.sendTime.^next
      m2.sendTime in m1.sendTime.^next

  --  (trace (send (enc n1 a (pubk b)))
      -- contains local values for "a" and "n1"
      m0.data.plaintext = init.init_a + init.init_n1

      one m0.data
      -- encrypted with public key of whoever is locally "b"
      -- recall "owners" takes us to private key, and then lookup in pairs
      m0.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(init.init_b)]
      m0.sender = init
      init.init_b not in init
      --init.init_a = init
  --         (recv (enc n1 n2 (pubk a)))
      m1.data.plaintext = init.init_n1 + init.init_n2    
      init.init_n1 not in init.init_n2 
      one m1.data
      m1.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(init.init_a)]
      m1.receiver = init
  --         (send (enc n2 (pubk b)))))
      m2.data.plaintext = init.init_n2   
      one m2.data   
      m2.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(init.init_b)]
      m2.sender = init    
    }      
  }

  all resp: Resp | {  
    some m0: Message | 
    some m1: Message - m0 | 
    some m2: Message - m1 - m0 | {  

      m1.sendTime in m0.sendTime.^next
      m2.sendTime in m1.sendTime.^next

    --(trace (recv (enc n1 a (pubk b)))                
      -- contains local values for "a" and "n1"
      m0.data.plaintext = resp.resp_a + resp.resp_n1
      one m0.data
      -- encrypted with public key of whoever is locally "b"
      -- recall "owners" takes us to private key, and then lookup in pairs
      m0.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(resp.resp_b)]
      m0.receiver = resp
  --       (send (enc n1 n2 (pubk a)))
      m1.data.plaintext = resp.resp_n1 + resp.resp_n2     
      one m1.data
      m1.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(resp.resp_a)]
      m1.sender = resp
  --        (recv (enc n2 (pubk b))))))
      m2.data.plaintext = resp.resp_n2 
      one m2.data     
      m2.data.encryptionKey = KeyPairs.pairs[KeyPairs.owners.(resp.resp_b)]
      m2.receiver = resp
      resp.resp_a not in resp.resp_b
      
    }      
  }
}

----- SKELETON DEFNS -----

/*
(defskeleton ns
 (vars (b name) (n1 text))
 ; ASSUME: 2nd "b" is referring to the variable declared line above
 ; ASSUME: 1st "b" is referring to the variable declared in defrole of protocol
;;; The initiator point-of-view
(defskeleton ns
  (vars (a b name) (n1 text))
  (defstrand init 3 (a a) (b b) (n1 n1))
  (non-orig (privk b) (privk a))
  (uniq-orig n1)
  (comment "Initiator point-of-view"))

;;; The responder point-of-view
(defskeleton ns
  (vars (a b name) (n2 text))
  (defstrand resp 3 (a a) (b b) (n2 n2))
  (non-orig (privk a) (privk b))
  (uniq-orig n2)
  (comment "Responder point-of-view"))
*/
-- TODO: look at defskeleton and defstrand docs
--  what is the (b b)? ANSWER: this is defining the variable b in the role to the *value* of b
--  why say "3" there if init/resp traces have 3 messages each?  This is the max height.  You could not put more than 3 here, but you can put less than 3

-- Assume: defskeleton ns: the strands herein are NS roles
-- Assume: defstrand init ... is talking about a specific init strand

-- First cut
abstract sig SkeletonNS {}
one sig SkeletonNS_0 extends SkeletonNS {
  s0_a: one name,
  s0_b: one name,
  s0_n1: one text,
  strand0_0: one Init
}
one sig SkeletonNS_1 extends SkeletonNS {
  s1_a: one name,
  s1_b: one name,
  s1_n2: one text,
  strand1_0: one Resp
}

pred constrain_skeletonNS_0 {
  -- (defstrand init 3 (a a) (b b) (n1 n1))
  SkeletonNS_0.strand0_0.init_a = SkeletonNS_0.s0_a
  SkeletonNS_0.strand0_0.init_b = SkeletonNS_0.s0_b
  SkeletonNS_0.strand0_0.init_n1 = SkeletonNS_0.s0_n1
  
  -- (non-orig (privk b) (privk a))
  -- (uniq-orig n1)
  -- ASSUME: meaning of these operators is correct ; it is likely not quite
  --   do we, e.g., need to also assume that the generation EXISTS for unique?

  all a: name - SkeletonNS_0.strand0_0.agent | 
    SkeletonNS_0.s0_n1 not in a.generated_times.Timeslot

-- TODO: never re-wrote non-orig for this
}
pred constrain_skeletonNS_1 {
  -- (defstrand resp 3 (a a) (b b) (n2 n2))
  SkeletonNS_1.strand1_0.resp_a = SkeletonNS_1.s1_a
  SkeletonNS_1.strand1_0.resp_b = SkeletonNS_1.s1_b
  SkeletonNS_1.strand1_0.resp_n2 = SkeletonNS_1.s1_n2

  -- (non-orig (privk b) (privk a))
  -- (uniq-orig n2)

  all a: name - SkeletonNS_1.strand1_0.agent |  -- good example of why we want types
    SkeletonNS_1.s1_n2 not in a.generated_times.Timeslot
}

-- Don't expect skeleton defns to be displayed; they are probably invisible
-- structure that constrains the instance found.

pred exploit_search {
  some t: text | 
  some c: Ciphertext | 
  some m: Message | 
  some t2: text - t | 
  some c2: Ciphertext - c | 
  some m2: Message - m | 
  {
    m.data = c and
    t in c.plaintext and
    t in (Attacker.learned_times).Timeslot and

    m2.data = c2 and
    t2 in c2.plaintext and
    t2 in (Attacker.learned_times).Timeslot
  }

}

pred temporary {
  -- upper bounds for one sig have size > 1 at the moment; fix
  one Attacker

  -- for checking, debugging:
  all a1, a2: name | { 
    -- If one has a key, keys are different
    (some KeyPairs.owners.a1 and a1 != a2) implies 
      (KeyPairs.owners.a1 != KeyPairs.owners.a2)
  }

  -- TODO move some of these into the wellformedness pred
  
  all p: PrivateKey | one p.(KeyPairs.owners) 

  agent.Attacker = AttackerStrand

  -- number of keys greater than 0
  #Key > 0
}



-- 2 publickey, 3 ciphertext, 3 agent
-- Sigs that we have: Datum, Key, PrivateKey, PublicKey, SymmetricKey, Agent, Attacker, Ciphertext, Text, Message, Timeslot, KeyPairs

option verbose 5
option solver MiniSatProver
option logtranslation 1
option coregranularity 1
option core_minimization hybrid

run {
  temporary
  wellformed
  ns_execution
  constrain_skeletonNS_0
  constrain_skeletonNS_1
  exploit_search
} for exactly 16 mesg, exactly 6 Key, 
			exactly 2 SkeletonNS, 
			exactly 1 SkeletonNS_0,
 		 	exactly 1 SkeletonNS_1, 
			exactly 3 PrivateKey, 
			exactly 3 PublicKey, 
			exactly 0 skey, 
			exactly 1 Init, 
			exactly 1 Resp,
                        exactly 3 strand,
			exactly 1 Attacker,
                        exactly 1 AttackerStrand,
			exactly 5 Ciphertext, 
			exactly 2 text,
			exactly 6 Message,
 			exactly 6 Timeslot, 
			exactly 1 KeyPairs, 
			exactly 3 name for {next is linear}
